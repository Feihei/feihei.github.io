<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>主教中国象棋 Bishop Xiangqi</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #b19173, #6d7aa7);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
                padding: 20px;
            color: #cacaca;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            width: 100%;
            max-width: 800px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            font-size: 2.5rem;
            text-shadow: 0 0 10px rgba(112, 112, 112, 0.8);
            margin-bottom: 10px;
            color: #c7c7c7;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #adadad;
            margin-bottom: 10px;
        }
        
        .rules {
            background: rgba(70, 70, 70, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        
        .container {
            display: flex;
            gap: 30px;
            max-width: 1200px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .game-board {
            background: #3f3f3f;
            border: 4px solid #3f3f3f;
            border-radius: 8px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.7);
            padding: 20px;
            position: relative;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(9, 60px);
            grid-template-rows: repeat(10, 60px);
            position: relative;
        }
        
        .cell {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .white-cell {
            background-color: #cfcfcf;
        }
        
        .black-cell {
            background-color: #8f8f8f;
        }
        
        .piece {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease;
            position: relative;
            z-index: 10;
            user-select: none;
        }
        
        .piece.white {
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            color: #333;
            border: 2px solid #999;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.1);
        }
        
        .piece.black {
            background: linear-gradient(145deg, #333333, #000000);
            color: #fff;
            border: 2px solid #444;
        }
        
        .piece.selected {
            box-shadow: 0 0 0 4px rgb(255, 239, 147), 0 0 20px rgba(156, 144, 74, 0.8);
            transform: scale(1.1);
            z-index: 20;
        }
        
        .possible-move {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(220, 255, 174, 0.6);
            border-radius: 50%;
            z-index: 5;
            pointer-events: none;
            box-shadow: 0 0 5px rgba(111, 156, 74, 0.8);
        }
        
        .possible-capture {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid rgba(255, 50, 50, 0.7);
            border-radius: 50%;
            z-index: 5;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(255, 50, 50, 0.5);
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            width: 300px;
            height: fit-content;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        .status {
            background: rgba(82, 82, 82, 0.5);
            padding: 15px;
            border-radius: 8px;
            font-size: 1.2rem;
            text-align: center;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .status h2 {
            color: rgb(179, 179, 179);
            margin-bottom: 10px;
        }
        
        .btn {
            padding: 12px 20px;
            font-size: 1.1rem;
            background: linear-gradient(to bottom, #2b313d, #454e53);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .btn:hover {
            background: linear-gradient(to bottom, #6e7c9c, #454e53);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .special-rule {
            background: rgba(70, 70, 70, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 1rem;
        }
        
        .special-rule h3 {
            color: #ccc;
            margin-bottom: 10px;
            text-align: center;
        }
                
        .player-turn {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .turn-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        /* 添加难度选择按钮样式 */
        .difficulty-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .difficulty-btn {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
        }
        
        .difficulty-btn.active {
            background: linear-gradient(to bottom, #6e7c9c, #454e53);
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
               
        /* 九宫格外边框样式 */
        .palace-border {
            position: absolute;
            border: 3px solid rgba(255, 255, 255, 0.9);
            z-index: 15;
            pointer-events: none;
        }
        
        .river-highlight {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            border-bottom: dashed 3px rgba(255, 255, 255, 0.9);
            z-index: 15;
            pointer-events: none;
        }
        /* 添加走子提示标记样式 */
        .move-indicator {
            position: absolute;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            border: 3px solid;
            z-index: 25;
            pointer-events: none;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .move-indicator.white {
            border-color: rgba(255, 229, 80, 0.6);
            box-shadow: 0 0 5px 1px rgba(255, 229, 80, 0.4);
        }
        
        .move-indicator.black {
            border-color: rgba(255, 229, 80, 0.6);
            box-shadow: 0 0 5px 1px rgba(255, 229, 80, 0.4);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>主教中国象棋 Bishop Xiangqi - <span id="gameModeText">双人对弈</span></h1>
        <div class="subtitle">象的走法同国际象棋（斜线任意格，不可越子，可过河）</div>
        <div class="rules">白方先行 | 将死/困毙对方获胜 | 三步循环重复判和 | 其他规则同传统中国象棋</div>
    </div>
    <div class="container">
        <div class="game-board">
            <div class="board" id="chessboard">
                <!-- 棋盘通过JS生成 -->
            </div>
        </div>
        <div class="controls">
            <div class="status" id="gameStatus">
                <h2>游戏状态</h2>
                <div id="statusText">白方回合，请走棋</div>
                <div class="player-turn">
                    <div class="turn-indicator" id="turnIndicator" style="background: white;"></div>
                    <span id="currentPlayer">白方回合</span>
                </div>
            </div>
            
            <button class="btn" id="restartBtn">重新开始</button>
            <button class="btn" id="undoBtn">悔棋</button>
            <button class="btn" id="modeBtn">切换为人机对战</button>
            <!-- 添加难度选择 -->
            <div class="special-rule">
                <h3>AI难度选择</h3>
                <div class="difficulty-buttons">
                    <button class="btn difficulty-btn" id="easyBtn">简单</button>
                    <button class="btn difficulty-btn active" id="mediumBtn">中等</button>
                    <button class="btn difficulty-btn" id="hardBtn">困难</button>
                </div>
                <p style="margin-top: 10px; font-size: 0.8rem; color: #aaa;">
                    难度越高，AI思考时间越长
                </p>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // 游戏状态
            const gameState = {
                board: [],
                currentPlayer: 'white', // 'white' 或 'black'
                selectedPiece: null,
                gameOver: false,
                moveHistory: [], // 跟踪棋盘状态
                possibleMoves: [], // 存储当前选中棋子的可移动位置
                gameMode: 'pvp', // 'pvp' 或 'pvc' (人机对战)
                aiThinking: false, // AI是否正在思考
                aiDifficulty: 'medium', // 'easy', 'medium', 'hard'
                aiDepths: { easy: 2, medium: 3, hard: 4 }, // 不同难度对应的搜索深度
            };

            // 棋子初始布局
            const initialSetup = [
                // 黑方 (上方)
                ['b_ju', 'b_ma', 'b_xiang', 'b_shi', 'b_jiang', 'b_shi', 'b_ma', 'b_xiang', 'b_ju'],
                [null, null, null, null, null, null, null, null, null],
                [null, 'b_pao', null, null, null, null, null, 'b_pao', null],
                ['b_bing', null, 'b_bing', null, 'b_bing', null, 'b_bing', null, 'b_bing'],
                [null, null, null, null, null, null, null, null, null],
                // 中间空白行
                [null, null, null, null, null, null, null, null, null],
                // 白方 (下方)
                ['w_bing', null, 'w_bing', null, 'w_bing', null, 'w_bing', null, 'w_bing'],
                [null, 'w_pao', null, null, null, null, null, 'w_pao', null],
                [null, null, null, null, null, null, null, null, null],
                ['w_ju', 'w_xiang', 'w_ma', 'w_shi', 'w_shuai', 'w_shi', 'w_xiang', 'w_ma', 'w_ju']
            ];
            
            // 棋子显示字符
            const pieceChars = {
                'w_ju': '車', 'w_ma': '馬', 'w_xiang': '相', 'w_shi': '士', 
                'w_shuai': '帅', 'w_pao': '炮', 'w_bing': '兵',
                'b_ju': '車', 'b_ma': '馬', 'b_xiang': '象', 'b_shi': '士', 
                'b_jiang': '将', 'b_pao': '炮', 'b_bing': '卒'
            };
            
            // 初始化棋盘
            const chessboard = document.getElementById('chessboard');
            const statusText = document.getElementById('statusText');
            const currentPlayerText = document.getElementById('currentPlayer');
            const turnIndicator = document.getElementById('turnIndicator');
            const gameModeText = document.getElementById('gameModeText');
            const modeBtn = document.getElementById('modeBtn');
            
            function initBoard() {
                chessboard.innerHTML = '';
                gameState.board = JSON.parse(JSON.stringify(initialSetup));
                gameState.currentPlayer = 'white';
                gameState.selectedPiece = null;
                gameState.gameOver = false;
                gameState.moveHistory = [];
                gameState.possibleMoves = [];
                gameState.aiThinking = false;
                
                statusText.textContent = '白方回合，请走棋';
                currentPlayerText.textContent = '白方回合';
                turnIndicator.style.background = 'white';

                // 创建棋盘格子
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.className = `cell ${(row + col) % 2 === 0 ? 'white-cell' : 'black-cell'}`;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // 为九宫格添加高亮标识
                        if ((row >= 0 && row <= 2 && col >= 3 && col <= 5) || 
                            (row >= 7 && row <= 9 && col >= 3 && col <= 5)) {
                        }
                        
                        // 在第4行底部显示河界虚线
                        if (row === 4 && col >= 0 && col <= 8) {
                        }
                        
                        // 添加棋子
                        const pieceId = gameState.board[row][col];
                        if (pieceId) {
                            const piece = document.createElement('div');
                            const player = pieceId.split('_')[0] === 'w' ? 'white' : 'black';
                            piece.className = `piece ${player}`;
                            piece.textContent = pieceChars[pieceId];
                            piece.dataset.piece = pieceId;
                            piece.dataset.row = row;
                            piece.dataset.col = col;
                            piece.addEventListener('click', handlePieceClick);
                            cell.appendChild(piece);
                        }
                        
                        cell.addEventListener('click', handleCellClick);
                        chessboard.appendChild(cell);
                    }
                }
                
                // 获取棋盘格子的尺寸
                const firstCell = document.querySelector('.cell');
                const cellSize = firstCell.offsetWidth;

                // 上方九宫格外边框
                const topPalaceBorder = document.createElement('div');
                topPalaceBorder.className = 'palace-border';
                topPalaceBorder.style.top = '0px';
                topPalaceBorder.style.left = `${3 * cellSize}px`; // 3 * cellSize
                topPalaceBorder.style.width = `${3 * cellSize}px`; // 3 * cellSize
                topPalaceBorder.style.height = `${3 * cellSize}px`; // 3 * cellSize
                chessboard.appendChild(topPalaceBorder);
                
                // 下方九宫格外边框
                const bottomPalaceBorder = document.createElement('div');
                bottomPalaceBorder.className = 'palace-border';
                bottomPalaceBorder.style.top = `${7 * cellSize}px`; // 7 * cellSize
                bottomPalaceBorder.style.left = `${3 * cellSize}px`; // 3 * cellSize
                bottomPalaceBorder.style.width = `${3 * cellSize}px`; // 3 * cellSize
                bottomPalaceBorder.style.height = `${3 * cellSize}px`; // 3 * cellSize
                chessboard.appendChild(bottomPalaceBorder);
                
                // 创建河界标识（只在第5行底部显示）
                const riverHighlight = document.createElement('div');
                riverHighlight.className = 'river-highlight';
                riverHighlight.style.top = `${5 * cellSize}px`; // 5 * cellSize
                riverHighlight.style.left = '0px';
                riverHighlight.style.width = `${9 * cellSize}px`; // 9 * cellSize
                chessboard.appendChild(riverHighlight);
                
                // 清除走子提示标记
                clearMoveIndicators();

                // 如果是人机对战且AI先手，则触发AI移动
                if (gameState.gameMode === 'pvc' && gameState.currentPlayer === 'black') {
                    setTimeout(makeAIMove, 500);
                }
            }
            
            // 切换游戏模式
            modeBtn.addEventListener('click', () => {
                if (gameState.gameMode === 'pvp') {
                    gameState.gameMode = 'pvc';
                    modeBtn.textContent = '切换为双人对战';
                    gameModeText.textContent = '人机对战';
                } else {
                    gameState.gameMode = 'pvp';
                    modeBtn.textContent = '切换为人机对战';
                    gameModeText.textContent = '双人对战';
                }
                initBoard();
            });
            
            // 处理棋子点击
            function handlePieceClick(event) {
                if (gameState.gameOver) return;
                
                // 如果是人机对战模式且AI正在思考，禁用点击
                if (gameState.gameMode === 'pvc' && gameState.aiThinking) return;
                
                event.stopPropagation();
                const piece = event.target;
                const pieceId = piece.dataset.piece;
                const player = pieceId.split('_')[0] === 'w' ? 'white' : 'black';
                const row = parseInt(piece.dataset.row);
                const col = parseInt(piece.dataset.col);
                
                // 如果已经有选中的棋子
                if (gameState.selectedPiece) {
                    // 检查是否点击了可被吃的棋子
                    const isMoveValid = gameState.possibleMoves.some(move => 
                        move[0] === row && move[1] === col
                    );
                    
                    if (isMoveValid && player !== gameState.currentPlayer) {
                        // 执行吃子操作
                        movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col);
                        return;
                    }
                    
                    // 如果点击的是自己的棋子，切换选中状态
                    if (player === gameState.currentPlayer) {
                        // 清除之前的选择
                        clearSelection();
                        
                        // 选中当前棋子
                        piece.classList.add('selected');
                        gameState.selectedPiece = {
                            element: piece,
                            id: pieceId,
                            row: row,
                            col: col
                        };
                        
                        // 显示可行走位置
                        showPossibleMoves(row, col, pieceId);
                        return;
                    }
                }
                
                // 只能选择当前玩家的棋子
                if (player !== gameState.currentPlayer) return;
                
                // 清除之前的选择
                clearSelection();
                
                // 选中当前棋子
                piece.classList.add('selected');
                gameState.selectedPiece = {
                    element: piece,
                    id: pieceId,
                    row: row,
                    col: col
                };
                
                // 显示可行走位置
                showPossibleMoves(row, col, pieceId);
            }
            
            // 处理格子点击
            function handleCellClick(event) {
                if (gameState.gameOver || !gameState.selectedPiece) return;
                
                // 如果是人机对战模式且AI正在思考，禁用点击
                if (gameState.gameMode === 'pvc' && gameState.aiThinking) return;
                
                const cell = event.currentTarget;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // 检查是否是可行走位置
                const isMoveValid = gameState.possibleMoves.some(move => 
                    move[0] === row && move[1] === col
                );
                
                if (!isMoveValid) return;
                
                // 执行移动
                movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col);
            }
            
            // 棋子基础移动规则
            function getBasicMoves(row, col, type, player) {
                const moves = [];
                const playerPrefix = player === 'white' ? 'w' : 'b';
                
                switch (type) {
                    case 'ju': // 车
                        // 水平方向
                        for (let c = col - 1; c >= 0; c--) {
                            if (!addMoveIfValid(row, c, playerPrefix, moves)) break;
                        }
                        for (let c = col + 1; c < 9; c++) {
                            if (!addMoveIfValid(row, c, playerPrefix, moves)) break;
                        }
                        // 垂直方向
                        for (let r = row - 1; r >= 0; r--) {
                            if (!addMoveIfValid(r, col, playerPrefix, moves)) break;
                        }
                        for (let r = row + 1; r < 10; r++) {
                            if (!addMoveIfValid(r, col, playerPrefix, moves)) break;
                        }
                        break;
                        
                    case 'ma': // 马
                        const maMoves = [
                            [row - 2, col - 1], [row - 2, col + 1], // 上
                            [row - 1, col - 2], [row - 1, col + 2], // 左上、右上
                            [row + 1, col - 2], [row + 1, col + 2], // 左下、右下
                            [row + 2, col - 1], [row + 2, col + 1]  // 下
                        ];
                        
                        maMoves.forEach(([r, c]) => {
                            // 检查蹩马腿
                            if (r >= 0 && r < 10 && c >= 0 && c < 9) {
                                const legRow = row + Math.sign(r - row) * (Math.abs(r - row) > 1 ? 1 : 0);
                                const legCol = col + Math.sign(c - col) * (Math.abs(c - col) > 1 ? 1 : 0);
                                
                                if (gameState.board[legRow][legCol] === null) {
                                    addMoveIfValid(r, c, playerPrefix, moves);
                                }
                            }
                        });
                        break;
                        
                    case 'xiang': // 象（国际象棋规则）
                        // 四个斜线方向
                        const directions = [
                            [-1, -1], [-1, 1], [1, -1], [1, 1]
                        ];
                        
                        directions.forEach(([dr, dc]) => {
                            for (let i = 1; i < 9; i++) {
                                const r = row + dr * i;
                                const c = col + dc * i;
                                
                                if (r < 0 || r >= 10 || c < 0 || c >= 9) break;
                                
                                if (!addMoveIfValid(r, c, playerPrefix, moves)) break;
                            }
                        });
                        break;
                        
                    case 'shi': // 士
                        const shiMoves = [
                            [row - 1, col - 1], [row - 1, col + 1],
                            [row + 1, col - 1], [row + 1, col + 1]
                        ];
                        
                        shiMoves.forEach(([r, c]) => {
                            // 只能在九宫格内移动
                            if (r >= 0 && r < 10 && c >= 3 && c <= 5) {
                                if (player === 'white' && r >= 7) {
                                    addMoveIfValid(r, c, playerPrefix, moves);
                                } else if (player === 'black' && r <= 2) {
                                    addMoveIfValid(r, c, playerPrefix, moves);
                                }
                            }
                        });
                        break;
                        
                    case 'shuai': // 帅
                    case 'jiang': // 将
                        const kingMoves = [
                            [row - 1, col], [row + 1, col],
                            [row, col - 1], [row, col + 1]
                        ];
                        
                        kingMoves.forEach(([r, c]) => {
                            // 只能在九宫格内移动
                            if (r >= 0 && r < 10 && c >= 3 && c <= 5) {
                                if (player === 'white' && r >= 7) {
                                    addMoveIfValid(r, c, playerPrefix, moves);
                                } else if (player === 'black' && r <= 2) {
                                    addMoveIfValid(r, c, playerPrefix, moves);
                                }
                            }
                        });
                        
                        // 将帅对脸规则（飞将）
                        const enemyKingType = player === 'white' ? 'b_jiang' : 'w_shuai';
                        // 向上检查
                        for (let r = row - 1; r >= 0; r--) {
                            const piece = gameState.board[r][col];
                            if (piece) {
                                if (piece === enemyKingType) {
                                    // 检查中间是否有棋子
                                    let hasPieceBetween = false;
                                    for (let i = row - 1; i > r; i--) {
                                        if (gameState.board[i][col]) {
                                            hasPieceBetween = true;
                                            break;
                                        }
                                    }
                                    if (!hasPieceBetween) {
                                        // 可以飞将
                                        moves.push([r, col]);
                                    }
                                }
                                break; // 遇到第一个棋子就停止
                            }
                        }
                        // 向下检查
                        for (let r = row + 1; r < 10; r++) {
                            const piece = gameState.board[r][col];
                            if (piece) {
                                if (piece === enemyKingType) {
                                    // 检查中间是否有棋子
                                    let hasPieceBetween = false;
                                    for (let i = row + 1; i < r; i++) {
                                        if (gameState.board[i][col]) {
                                            hasPieceBetween = true;
                                            break;
                                        }
                                    }
                                    if (!hasPieceBetween) {
                                        // 可以飞将
                                        moves.push([r, col]);
                                    }
                                }
                                break;
                            }
                        }
                        break;
                        
                    case 'pao': // 炮
                        // 水平方向
                        let hasJumped = false;
                        for (let c = col - 1; c >= 0; c--) {
                            if (!processPaoMove(row, c, playerPrefix, moves, hasJumped)) {
                                if (gameState.board[row][c]) hasJumped = true;
                            } else {
                                break;
                            }
                        }
                        
                        hasJumped = false;
                        for (let c = col + 1; c < 9; c++) {
                            if (!processPaoMove(row, c, playerPrefix, moves, hasJumped)) {
                                if (gameState.board[row][c]) hasJumped = true;
                            } else {
                                break;
                            }
                        }
                        
                        // 垂直方向
                        hasJumped = false;
                        for (let r = row - 1; r >= 0; r--) {
                            if (!processPaoMove(r, col, playerPrefix, moves, hasJumped)) {
                                if (gameState.board[r][col]) hasJumped = true;
                            } else {
                                break;
                            }
                        }
                        
                        hasJumped = false;
                        for (let r = row + 1; r < 10; r++) {
                            if (!processPaoMove(r, col, playerPrefix, moves, hasJumped)) {
                                if (gameState.board[r][col]) hasJumped = true;
                            } else {
                                break;
                            }
                        }
                        break;
                        
                    case 'bing': // 兵/卒
                        const bingMoves = [];
                        if (player === 'white') {
                            // 白方向上移动
                            bingMoves.push([row - 1, col]);
                            if (row <= 4) { // 过河后可以左右移动
                                bingMoves.push([row, col - 1], [row, col + 1]);
                            }
                        } else {
                            // 黑方向下移动
                            bingMoves.push([row + 1, col]);
                            if (row >= 5) { // 过河后可以左右移动
                                bingMoves.push([row, col - 1], [row, col + 1]);
                            }
                        }
                        
                        bingMoves.forEach(([r, c]) => {
                            if (r >= 0 && r < 10 && c >= 0 && c < 9) {
                                addMoveIfValid(r, c, playerPrefix, moves);
                            }
                        });
                        break;
                }
                return moves;
            }
            
            // 炮的特殊移动处理
            function processPaoMove(row, col, playerPrefix, moves, hasJumped) {
                if (row < 0 || row >= 10 || col < 0 || col >= 9) return true;
                
                const targetPiece = gameState.board[row][col];
                
                if (!hasJumped) {
                    if (targetPiece) {
                        // 遇到棋子后设置hasJumped为true，但该位置不能吃子
                        return false;
                    }
                    moves.push([row, col]);
                    return false;
                } else {
                    // 已经跳跃过，只能吃子
                    if (targetPiece) {
                        if (!targetPiece.startsWith(playerPrefix)) {
                            moves.push([row, col]);
                        }
                        return true; // 遇到棋子后停止
                    }
                    return false;
                }
            }
            
            // 辅助函数：添加有效移动
            function addMoveIfValid(row, col, playerPrefix, moves) {
                if (row < 0 || row >= 10 || col < 0 || col >= 9) return false;
                
                const targetPiece = gameState.board[row][col];
                // 如果目标位置为空或是敌方棋子，可以移动
                if (!targetPiece || !targetPiece.startsWith(playerPrefix)) {
                    moves.push([row, col]);
                }
                
                // 如果目标位置有棋子（无论是己方还是敌方），停止在该方向继续搜索
                return targetPiece === null;
            }
            
            // 辅助函数：检查移动后是否会被将军
            function wouldBeInCheck(fromRow, fromCol, toRow, toCol, player) {
                // 保存原始状态
                const originalPiece = gameState.board[toRow][toCol];
                const movingPiece = gameState.board[fromRow][fromCol];
                
                // 模拟移动
                gameState.board[toRow][toCol] = movingPiece;
                gameState.board[fromRow][fromCol] = null;
                
                // 找到己方将/帅的位置
                let kingPos = null;
                const kingType = player === 'white' ? 'w_shuai' : 'b_jiang';
                
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (gameState.board[row][col] === kingType) {
                            kingPos = { row, col };
                            break;
                        }
                    }
                    if (kingPos) break;
                }
                
                // 检查是否被将军
                let inCheck = false;
                if (kingPos) {
                    inCheck = isSquareAttacked(kingPos.row, kingPos.col, player);
                }
                
                // 恢复原始状态
                gameState.board[fromRow][fromCol] = movingPiece;
                gameState.board[toRow][toCol] = originalPiece;
                
                return inCheck;
            }

            // 检查是否为重复局面
            function isRepetitionDraw() {
                // 如果历史记录少于6步，不可能有三次重复
                if (gameState.moveHistory.length < 6) {
                    return false;
                }

                // 获取最近6步棋的走法
                const recentMoves = gameState.moveHistory.slice(-6);
                
                // 检查是否形成三次重复
                // 三次重复意味着：
                // 第2步与第0步互逆
                // 第4步与第0步相同
                // 第3步与第1步互逆
                // 第5步与第1步相同

                // 判断两个走法是否互逆
                const isReverseMove = (m1, m2) => {
                    return m1.fromRow === m2.toRow &&
                        m1.fromCol === m2.toCol &&
                        m1.toRow === m2.fromRow &&
                        m1.toCol === m2.fromCol;
                };

                // 判断两个走法是否相同
                const isSameMove = (m1, m2) => {
                    return m1.fromRow === m2.fromRow &&
                        m1.fromCol === m2.fromCol &&
                        m1.toRow === m2.toRow &&
                        m1.toCol === m2.toCol;
                };

                // 检查第2步是否与第0步互逆
                if (!isReverseMove(recentMoves[2], recentMoves[0])) {
                    return false;
                }

                // 检查第4步是否与第0步相同
                if (!isSameMove(recentMoves[4], recentMoves[0])) {
                    return false;
                }

                // 检查第3步是否与第1步互逆
                if (!isReverseMove(recentMoves[3], recentMoves[1])) {
                    return false;
                }

                // 检查第5步是否与第1步相同
                if (!isSameMove(recentMoves[5], recentMoves[1])) {
                    return false;
                }

                return true;
            }

            // 获取合法移动位置（过滤被将军走法）
            function getPossibleMoves(row, col, type, player) {
                const moves = getBasicMoves(row, col, type, player);
                // 过滤掉会导致己方被将军的移动
                return moves.filter(move => !wouldBeInCheck(row, col, move[0], move[1], player));
            }
            
            // 显示合法移动位置
            function showPossibleMoves(row, col, pieceId) {
                clearPossibleMoves();
                
                const [playerPrefix, type] = pieceId.split('_');
                const player = playerPrefix === 'w' ? 'white' : 'black';
                const moves = getPossibleMoves(row, col, type, player);
                
                // 保存可移动位置
                gameState.possibleMoves = moves;
                
                moves.forEach(move => {
                    const [targetRow, targetCol] = move;
                    const targetPiece = gameState.board[targetRow][targetCol];
                    
                    if (targetPiece) {
                        // 吃子位置 - 红色边框
                        const marker = document.createElement('div');
                        marker.className = 'possible-capture';
                        marker.dataset.row = targetRow;
                        marker.dataset.col = targetCol;
                        
                        const cell = document.querySelector(`.cell[data-row="${targetRow}"][data-col="${targetCol}"]`);
                        cell.appendChild(marker);
                    } else {
                        // 空位置 - 绿色圆点
                        const marker = document.createElement('div');
                        marker.className = 'possible-move';
                        marker.dataset.row = targetRow;
                        marker.dataset.col = targetCol;
                        
                        const cell = document.querySelector(`.cell[data-row="${targetRow}"][data-col="${targetCol}"]`);
                        cell.appendChild(marker);
                    }
                });
            }
            
            // 检查玩家是否被将死或困毙
            function isPlayerMated(player) {
                // 检查玩家是否有任何合法移动
                const playerPrefix = player === 'white' ? 'w' : 'b';
                
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 9; col++) {
                        const pieceId = gameState.board[row][col];
                        
                        // 找到该玩家的棋子
                        if (pieceId && pieceId.startsWith(playerPrefix)) {
                            const type = pieceId.split('_')[1];
                            // 获取所有可能的移动
                            const moves = getPossibleMoves(row, col, type, player);
                            
                            // 如果有任何一个合法移动，玩家未被将死
                            if (moves.length > 0) {
                                return false;
                            }
                        }
                    }
                }
                
                // 没有合法移动，被将死或困毙
                return true;
            }
            
            // 检查某个位置是否被对方攻击
            function isSquareAttacked(row, col, player) {
                const enemyPrefix = player === 'white' ? 'b' : 'w';
                
                // 检查所有敌方棋子
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 9; c++) {
                        const pieceId = gameState.board[r][c];
                        if (pieceId && pieceId.startsWith(enemyPrefix)) {
                            const type = pieceId.split('_')[1];
                            const enemyPlayer = enemyPrefix === 'w' ? 'white' : 'black';
                            const moves = getBasicMoves(r, c, type, enemyPlayer);
                            
                            // 检查是否有攻击到目标位置的移动
                            if (moves.some(move => move[0] === row && move[1] === col)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            // 检查当前玩家是否被将军
            function isInCheck(player) {
                // 找到该玩家的将/帅位置
                const kingType = player === 'white' ? 'w_shuai' : 'b_jiang';
                let kingPos = null;
                
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (gameState.board[row][col] === kingType) {
                            kingPos = { row, col };
                            break;
                        }
                    }
                    if (kingPos) break;
                }
                
                // 如果找不到将/帅，返回false
                if (!kingPos) return false;
                
                // 检查将/帅是否被攻击
                return isSquareAttacked(kingPos.row, kingPos.col, player);
            }

            // 添加走子提示标记
            function addMoveIndicator(row, col, player) {
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                if (cell) {
                    // 检查是否已有标记，如果有则先移除
                    const existingIndicator = cell.querySelector('.move-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }
                    
                    const indicator = document.createElement('div');
                    indicator.className = `move-indicator ${player}`;
                    cell.appendChild(indicator);
                }
            }
            
            // 清除所有走子提示标记
            function clearMoveIndicators() {
                document.querySelectorAll('.move-indicator').forEach(marker => marker.remove());
            }

            // 移动棋子
            function movePiece(fromRow, fromCol, toRow, toCol) {
                const pieceId = gameState.board[fromRow][fromCol];
                const targetPiece = gameState.board[toRow][toCol];

                // 检查是否形成三步重复局面
                if (isRepetitionDraw(fromRow, fromCol, toRow, toCol)) {
                    // 显示和棋信息
                    statusText.innerHTML = `<span style="color:yellow;font-weight:bold;">和棋！出现三步重复局面</span>`;
                    currentPlayerText.textContent = '游戏结束';
                    turnIndicator.style.background = 'transparent';
                    gameState.gameOver = true; // 设置游戏结束状态
                    return;
                }

                // 保存移动历史
                gameState.moveHistory.push({
                    fromRow, fromCol, toRow, toCol,
                    pieceMoved: pieceId,
                    pieceCaptured: targetPiece
                });
                
                // 清除所有旧的走子标记
                clearMoveIndicators();

                // 更新棋盘状态
                gameState.board[fromRow][fromCol] = null;
                gameState.board[toRow][toCol] = pieceId;
                
                // 更新界面
                updateBoard();
                
                // 添加走子提示标记（原位置和新位置）
                addMoveIndicator(fromRow, fromCol, pieceId.startsWith('w') ? 'white' : 'black');
                addMoveIndicator(toRow, toCol, pieceId.startsWith('w') ? 'white' : 'black');
                
                // 清除选择
                clearSelection();
                clearPossibleMoves();
                
                // 检查是否将死或困毙对方
                const opponent = gameState.currentPlayer === 'white' ? 'black' : 'white';
                if (isPlayerMated(opponent)) {
                    gameState.gameOver = true;
                    statusText.innerHTML = `<span style="color:gold;font-weight:bold;">${gameState.currentPlayer === 'white' ? '白方' : '黑方'}胜利！</span>`;
                    currentPlayerText.textContent = '游戏结束';
                    turnIndicator.style.background = 'transparent';
                    updateBoard();
                    return;
                }
                
                if (!gameState.gameOver) {
                    // 切换玩家
                    gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
                    
                    // 检查新回合的玩家是否被将军
                    const inCheck = isInCheck(gameState.currentPlayer);
        
                    if (inCheck) {
                        // 如果被将军，突出显示
                        statusText.innerHTML = `<span style="color:red;font-weight:bold;">${gameState.currentPlayer === 'white' ? '白方' : '黑方'}被将军！</span>`;
                        currentPlayerText.textContent = `${gameState.currentPlayer === 'white' ? '白方' : '黑方'}回合（将军）`;
                    } else {
                        statusText.textContent = `${gameState.currentPlayer === 'white' ? '白方' : '黑方'}回合，请走棋`;
                        currentPlayerText.textContent = `${gameState.currentPlayer === 'white' ? '白方' : '黑方'}回合`;
                    }
                    
                    turnIndicator.style.background = gameState.currentPlayer === 'white' ? 'white' : 'black';

                    // 如果是人机对战且轮到AI，则触发AI移动
                    if (gameState.gameMode === 'pvc' && gameState.currentPlayer === 'black' && !gameState.gameOver) {
                        setTimeout(makeAIMove, 500);
                    }
                }
            }
            
            // AI

            // 棋子基本价值
            const pieceValues = {
                'ju': 9,    // 车
                'ma': 5,    // 马
                'xiang': 5, // 象
                'shi': 2,   // 士
                'shuai': 100, // 帅
                'jiang': 100, // 将
                'pao': 5, // 炮
                'bing': 1,   // 兵/卒
            };

            // 棋子位置价值表
            const positionValues = {
                'bing': [  // 兵/卒
                    [0,  0,  0,  0,  0,  0,  0,  0,  0]
                    [0,  0,  0,  0,  0,  0,  0,  0,  0]
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [1,  0,  1,  0,  1,  0,  1,  0,  1],
                    [2,  0,  2,  0,  2,  0,  2,  0,  2],
                    [4,  4,  4,  4,  4,  4,  4,  4,  4],
                    [4,  4,  4,  4,  4,  4,  4,  4,  4],
                    [5,  5,  5,  5,  5,  5,  5,  5,  5],
                    [5,  5,  5,  5,  5,  5,  5,  5,  5],
                    [0,  1,  2,  3,  3,  3,  2,  1,  0]
                ],
                'pao': [  // 炮
                    [1,  1,  1,  1,  1,  1,  1,  1,  1],
                    [1,  1,  1,  1,  1,  1,  1,  1,  1],
                    [2,  1,  2,  2,  4,  2,  2,  1,  2],
                    [1,  1,  1,  1,  4,  1,  1,  1,  1],
                    [2,  2,  2,  2,  4,  2,  2,  2,  2],
                    [2,  2,  2,  2,  4,  2,  2,  2,  2],
                    [2,  2,  2,  2,  4,  2,  2,  2,  2],
                    [2,  1,  1,  2,  3,  2,  1,  1,  2],
                    [2,  1,  1,  1,  1,  1,  1,  1,  2],
                    [3,  3,  2,  1,  1,  1,  2,  3,  3]
                ],
                'ma': [  // 马
                    [0,  1,  1,  1,  1,  1,  1,  1,  0],
                    [1,  1,  1,  1,  1,  1,  1,  1,  1],
                    [1,  2,  3,  2,  2,  2,  3,  2,  1],
                    [1,  2,  2,  2,  3,  2,  2,  2,  1],
                    [1,  2,  2,  3,  3,  3,  2,  2,  1],
                    [1,  2,  2,  3,  3,  3,  2,  2,  1],
                    [1,  2,  3,  2,  3,  2,  3,  2,  1],
                    [1,  2,  3,  3,  1,  3,  3,  2,  1],
                    [1,  2,  3,  2,  1,  2,  3,  2,  1],
                    [0,  1,  1,  1,  1,  1,  1,  1,  0]
                ],
                'xiang': [  // 象（使用国际象棋象的走法）
                    [1,  1,  1,  1,  1,  1,  1,  1,  1],
                    [1,  2,  2,  2,  2,  2,  2,  2,  1],
                    [1,  2,  3,  3,  3,  3,  3,  2,  1],
                    [1,  2,  3,  4,  4,  4,  3,  2,  1],
                    [1,  2,  3,  4,  5,  4,  3,  2,  1],
                    [1,  2,  3,  4,  5,  4,  3,  2,  1],
                    [1,  2,  3,  4,  4,  4,  3,  2,  1],
                    [1,  2,  3,  3,  3,  3,  3,  2,  1],
                    [1,  2,  2,  2,  2,  2,  2,  2,  1],
                    [1,  1,  1,  1,  1,  1,  1,  1,  1]
                ],
                'shi': [  // 士
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [0,  0,  0,  2,  0,  2,  0,  0,  0],
                    [0,  0,  0,  0,  3,  0,  0,  0,  0],
                    [0,  0,  0,  2,  0,  2,  0,  0,  0]
                ],
                'ju': [  // 车
                    [2,  4,  2,  3,  1,  3,  2,  4,  2],
                    [2,  4,  2,  3,  1,  3,  2,  4,  2],
                    [2,  4,  2,  3,  2,  3,  2,  4,  2],
                    [2,  4,  2,  3,  2,  3,  2,  4,  2],
                    [4,  4,  4,  4,  4,  4,  4,  4,  4],
                    [4,  4,  4,  4,  4,  4,  4,  4,  4],
                    [2,  4,  2,  3,  3,  3,  2,  4,  2],
                    [2,  4,  2,  3,  3,  3,  2,  4,  2],
                    [2,  4,  2,  3,  3,  3,  2,  4,  2],
                    [4,  4,  4,  4,  2,  4,  4,  4,  4]
                ],
                'shuai': [  // 帅/将
                    [0,  0,  0,  1,  1,  1,  0,  0,  0],
                    [0,  0,  0,  1,  1,  1,  0,  0,  0],
                    [0,  0,  0,  1,  1,  1,  0,  0,  0],
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [0,  0,  0,  0,  0,  0,  0,  0,  0],
                    [0,  0,  0,  1,  1,  1,  0,  0,  0],
                    [0,  0,  0,  1,  1,  1,  0,  0,  0],
                    [0,  0,  0,  1,  1,  1,  0,  0,  0]
                ]
            };
            
            // 评估棋子位置价值
            function evaluatePositionValues() {
                let score = 0;
                
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 9; col++) {
                        const pieceId = gameState.board[row][col];
                        if (pieceId) {
                            const type = pieceId.split('_')[1];
                            const player = pieceId.split('_')[0];
                            
                            // 获取该棋子的位置价值
                            let positionValue = 0;
                            const positionType = type === 'jiang' ? 'shuai' : type; // 将军和帅的位置价值相同
                            
                            // 检查positionValues中是否存在该类型的位置价值数据
                            if (positionValues[positionType]) {
                                // 确保行索引在有效范围内
                                const rowIndex = player === 'w' ? (9 - row) : row;
                                if (rowIndex >= 0 && rowIndex < 10 && 
                                    positionValues[positionType][rowIndex] && 
                                    positionValues[positionType][rowIndex][col] !== undefined) {
                                    positionValue = positionValues[positionType][rowIndex][col];
                                }
                            }
                            
                            // 白方棋子减分，黑方棋子加分
                            score += player === 'w' ? -positionValue : positionValue;
                        }
                    }
                }
                
                return score;
            }
            
            // Minimax算法
            function minimax(depth, alpha, beta, isMaximizing) {
                // 达到最大深度或游戏结束，返回评估值
                if (depth === 0) {
                    return evaluateBoard();
                }
                
                const player = isMaximizing ? 'black' : 'white';
                const possibleMoves = getAllPossibleMoves(player);
                
                if (isMaximizing) {
                    let maxEval = -Infinity;
                    
                    for (const move of possibleMoves) {
                        // 执行移动
                        const originalPiece = gameState.board[move.toRow][move.toCol];
                        gameState.board[move.fromRow][move.fromCol] = null;
                        gameState.board[move.toRow][move.toCol] = move.pieceId;
                        
                        // 检查是否将死对方
                        if (originalPiece && (originalPiece.includes('shuai') || originalPiece.includes('jiang'))) {
                            // 恢复棋盘
                            gameState.board[move.fromRow][move.fromCol] = move.pieceId;
                            gameState.board[move.toRow][move.toCol] = originalPiece;
                            return 1000; // 很大的正数表示胜利
                        }
                        
                        const eval = minimax(depth - 1, alpha, beta, false);
                        
                        // 恢复棋盘
                        gameState.board[move.fromRow][move.fromCol] = move.pieceId;
                        gameState.board[move.toRow][move.toCol] = originalPiece;
                        
                        maxEval = Math.max(maxEval, eval);
                        alpha = Math.max(alpha, eval);
                        if (beta <= alpha) {
                            break; // Alpha-Beta剪枝
                        }
                    }
                    
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    
                    for (const move of possibleMoves) {
                        // 执行移动
                        const originalPiece = gameState.board[move.toRow][move.toCol];
                        gameState.board[move.fromRow][move.fromCol] = null;
                        gameState.board[move.toRow][move.toCol] = move.pieceId;
                        
                        // 检查是否将死对方
                        if (originalPiece && (originalPiece.includes('shuai') || originalPiece.includes('jiang'))) {
                            // 恢复棋盘
                            gameState.board[move.fromRow][move.fromCol] = move.pieceId;
                            gameState.board[move.toRow][move.toCol] = originalPiece;
                            return -1000; // 很大的负数表示失败
                        }
                        
                        const eval = minimax(depth - 1, alpha, beta, true);
                        
                        // 恢复棋盘
                        gameState.board[move.fromRow][move.fromCol] = move.pieceId;
                        gameState.board[move.toRow][move.toCol] = originalPiece;
                        
                        minEval = Math.min(minEval, eval);
                        beta = Math.min(beta, eval);
                        if (beta <= alpha) {
                            break; // Alpha-Beta剪枝
                        }
                    }
                    
                    return minEval;
                }
            }
            
            // 获取所有可能的移动
            function getAllPossibleMoves(player) {
                const moves = [];
                const playerPrefix = player === 'white' ? 'w' : 'b';
                
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 9; col++) {
                        const pieceId = gameState.board[row][col];
                        
                        if (pieceId && pieceId.startsWith(playerPrefix)) {
                            const type = pieceId.split('_')[1];
                            const possibleMoves = getPossibleMoves(row, col, type, player);
                            
                            possibleMoves.forEach(([toRow, toCol]) => {
                                moves.push({
                                    pieceId,
                                    fromRow: row,
                                    fromCol: col,
                                    toRow,
                                    toCol
                                });
                            });
                        }
                    }
                }
                
                return moves;
            }
            
            // 评估棋盘状态
            function evaluateBoard() {
                let score = 0;
                
                // 1.棋子基本价值评估
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 9; col++) {
                        const pieceId = gameState.board[row][col];
                        
                        if (pieceId) {
                            const type = pieceId.split('_')[1];
                            const player = pieceId.split('_')[0];
                            const value = pieceValues[type];
                            
                            // 白方棋子减分，黑方棋子加分
                            score += player === 'w' ? -value : value;
                        }
                    }
                }
                
                // 2.棋子位置价值评估（权重0.05）
                score += evaluatePositionValues()*0.05;
                
                return score;
            }
            
            // 寻找最佳移动
            function findBestMove(depth) {
                const possibleMoves = getAllPossibleMoves('black');
                
                // 如果没有可能的移动，返回null
                if (possibleMoves.length === 0) return null;
                
                let bestMove = null;
                let bestValue = -Infinity;
                
                // 评估每个可能的移动
                for (const move of possibleMoves) {
                    // 执行移动
                    const originalPiece = gameState.board[move.toRow][move.toCol];
                    gameState.board[move.fromRow][move.fromCol] = null;
                    gameState.board[move.toRow][move.toCol] = move.pieceId;
                    
                    // 检查是否将死对方
                    if (originalPiece && (originalPiece.includes('shuai') || originalPiece.includes('jiang'))) {
                        // 恢复棋盘
                        gameState.board[move.fromRow][move.fromCol] = move.pieceId;
                        gameState.board[move.toRow][move.toCol] = originalPiece;
                        return move; // 直接返回这个能赢的移动
                    }
                    
                    // 递归评估
                    const moveValue = minimax(depth - 1, -Infinity, Infinity, false);
                    
                    // 恢复棋盘
                    gameState.board[move.fromRow][move.fromCol] = move.pieceId;
                    gameState.board[move.toRow][move.toCol] = originalPiece;
                    
                    // 添加一个小的随机扰动，让AI有更多变化
                    const randomFactor = (Math.random() - 0.5) * 0.1; // ±0.05的随机扰动
                    
                    // 更新最佳移动 - 如果值相同，随机因素可能会影响选择
                    if (moveValue + randomFactor > bestValue) {
                        bestValue = moveValue + randomFactor;
                        bestMove = move;
                    }
                }
                
                return bestMove;
            }
            
            // AI移动函数，使用当前难度
            function getDifficultyName(difficulty) {
                const names = { easy: '简单', medium: '中等', hard: '困难' };
                return names[difficulty];
            }
            
            function makeAIMove() {
                if (gameState.gameOver || gameState.aiThinking) return;
                
                gameState.aiThinking = true;
                statusText.textContent = `AI思考中 (${getDifficultyName(gameState.aiDifficulty)}难度)...`;
                
                // 根据难度设置思考时间
                const thinkTime = gameState.aiDifficulty === 'easy' ? 500 : 
                                 gameState.aiDifficulty === 'medium' ? 800 : 1200;
                
                setTimeout(() => {
                    const depth = gameState.aiDepths[gameState.aiDifficulty];
                    const bestMove = findBestMove(depth);
                    
                    // 修改: 添加对bestMove为null的处理，防止AI被将死时游戏卡住
                    if (bestMove) {
                        movePiece(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                    } else {
                        // AI无合法移动，说明被将死或困毙，游戏结束
                        gameState.gameOver = true;
                        statusText.innerHTML = `<span style="color:gold;font-weight:bold;">白方胜利！</span>`;
                        currentPlayerText.textContent = '游戏结束';
                        turnIndicator.style.background = 'transparent';
                        gameState.aiThinking = false;
                        return;
                    }
                    
                    gameState.aiThinking = false;
                }, thinkTime);
            }

            // 更新棋盘显示
            function updateBoard() {
                // 清空棋盘
                document.querySelectorAll('.piece').forEach(piece => piece.remove());
                
                // 重新放置棋子
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 9; col++) {
                        const pieceId = gameState.board[row][col];
                        if (pieceId) {
                            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                            const piece = document.createElement('div');
                            const player = pieceId.split('_')[0] === 'w' ? 'white' : 'black';
                            piece.className = `piece ${player}`;
                            piece.textContent = pieceChars[pieceId];
                            piece.dataset.piece = pieceId;
                            piece.dataset.row = row;
                            piece.dataset.col = col;
                            piece.addEventListener('click', handlePieceClick);
                            cell.appendChild(piece);
                        }
                    }
                }
            }
            
            // 清除选择
            function clearSelection() {
                document.querySelectorAll('.piece.selected').forEach(piece => {
                    piece.classList.remove('selected');
                });
                gameState.selectedPiece = null;
                gameState.possibleMoves = [];
            }
            
            // 清除可行走标记
            function clearPossibleMoves() {
                document.querySelectorAll('.possible-move, .possible-capture').forEach(marker => {
                    marker.remove();
                });
            }
            
            // 事件监听
            document.getElementById('restartBtn').addEventListener('click', initBoard);
            document.getElementById('undoBtn').addEventListener('click', undoMove);
            
            // 悔棋功能
            function undoMove() {
                if (gameState.moveHistory.length === 0 || gameState.gameOver) return;
                
                const lastMove = gameState.moveHistory.pop();
                
                // 恢复棋盘状态
                gameState.board[lastMove.fromRow][lastMove.fromCol] = lastMove.pieceMoved;
                gameState.board[lastMove.toRow][lastMove.toCol] = lastMove.pieceCaptured;
                
                // 恢复玩家回合
                gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
                gameState.gameOver = false;
                
                // 更新界面
                updateBoard();

                // 如果有历史记录，显示上一步的走子提示
                if (gameState.moveHistory.length > 0) {
                    const prevMove = gameState.moveHistory[gameState.moveHistory.length - 1];
                    const player = prevMove.pieceMoved.startsWith('w') ? 'white' : 'black';
                    addMoveIndicator(prevMove.fromRow, prevMove.fromCol, player);
                }
                
                statusText.textContent = `${gameState.currentPlayer === 'white' ? '白方' : '黑方'}回合，请走棋`;
                currentPlayerText.textContent = `${gameState.currentPlayer === 'white' ? '白方' : '黑方'}回合`;
                turnIndicator.style.background = gameState.currentPlayer === 'white' ? 'white' : 'black';
            }

            // 初始化时添加难度按钮事件监听
            const easyBtn = document.getElementById('easyBtn');
            const mediumBtn = document.getElementById('mediumBtn');
            const hardBtn = document.getElementById('hardBtn');
            
            easyBtn.addEventListener('click', () => setDifficulty('easy'));
            mediumBtn.addEventListener('click', () => setDifficulty('medium'));
            hardBtn.addEventListener('click', () => setDifficulty('hard'));
            
            // 设置难度函数
            function setDifficulty(difficulty) {
                gameState.aiDifficulty = difficulty;
                
                // 更新按钮样式
                easyBtn.classList.remove('active');
                mediumBtn.classList.remove('active');
                hardBtn.classList.remove('active');
                
                document.getElementById(`${difficulty}Btn`).classList.add('active');
                
                statusText.textContent = `已设置为${getDifficultyName(difficulty)}难度`;
                setTimeout(() => {
                    if (!gameState.aiThinking && gameState.currentPlayer === 'black' && gameState.gameMode === 'pvc') {
                        statusText.textContent = '黑方回合，请走棋';
                    }
                }, 1000);
            }
            
            // 初始化游戏
            initBoard();
        });
    </script>
</body>
</html>